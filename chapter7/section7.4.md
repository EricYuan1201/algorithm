# day30 51. N皇后，回溯总结 


## 1.回溯认识：

	组合是回溯里面最简单的。
	回溯的本质我已经知道了，一般是求总和的个数，对一个元素可以先尝试加入，然后获取所有的可能，
	然后再取消加入的这个元素，加入下一个元素。
	利用了递归的思想。如果是获取所有元素，首先是有遍历。
	
## 1.题型总结：

### 组合

>组合的题是回溯三大类里面代码最少的。组合是求和，[1,2,3]和[2,1,3]的解是一样的。

	  1.for循环
	  2.dfs
	  3.从begin开始，下一次到i/i+1 （要看是否使用重复元素！）
	  4.要注意new ArrayList(list1)
	  5.如果有重复，就Arrays.sort()，然后if(arr[i] == arr[i-1]) continue.
	  6.dfs里面一定要有终止条件。


>排列，是求一个数组可能的排列方式，全排列中 [1,2,3] 和 [2,1,3] 都是解。
 
	  1.每次都是从0开始遍历。（为什么从0开始遍历，因为需要获取所有可能的解）
	  2.开始使用isUsed数组了。因为每次都是从0，需要在下一次循环的时候越过某些元素。
	  3.终止条件是，通过depth判断的，不用depth也可以，直接使用count。
	  4.list.remove(index)
	  5.给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。
	    带有重复数字，最难理解的其实就是那个 ![nums[i-1]]
	    

**看了一个老哥的讲解，大概明白其思路了。**
	    	
	    
	如果前一个“相同元素”未被使用过，则不使用当前元素。 例如[1 2 2‘]可能出现[1 2 2'] 和[1 2‘ 2] 的情况。
	如果“存在前一个相同元素” 且“未被使用过”, 当现有排列是[1 2']时，
	原来的数组[1 2 2‘]中2’存在前一个元素2与其相同，且此时2未被访问过，跳过。
	[1 2 2']的排列先于[1 2' 2]存在，因此可以去除。
	
	
	正常的情况下，应该是前面那个元素用过才是正解，说明是第一次排列。
	如果前面那个元素未用过，说明使用的是1，2’，2，这种情况下和前面的已经重复了。



>子集 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。

	  1.子集的dfs是最少的，其实不是最少的，只是抽到了最外层。
	  2.终止条件，每次dfs都要把结果加进去。如果begin == length 也终止。
	  3.从begin开始，到i+1. ！！！ 卡了半小时
	  4.依然是和上次一样跳过逻辑。	
	  5.原来组合和子集都是从i，而不是从begin开始的。

## 最后总结

	1.组合都是有begin这个元素，但是下面都是 i+1
	2.排列没有begin这个元素，全都从0开始，使用了isUsed这个概念。
	